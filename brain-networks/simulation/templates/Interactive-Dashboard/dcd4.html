<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCD 4.0 Dashboard ‚Äî BETA v0.3.3</title>
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a1a1a;
            line-height: 1.6;
        }

        .dashboard {
            max-width: 1900px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 25px 30px;
            border-radius: 16px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            border-left: 6px solid #667eea;
        }

        .header h1 {
            color: #667eea;
            font-size: 2.2em;
            font-weight: 800;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .header .subtitle {
            color: #555;
            font-size: 0.95em;
            font-weight: 500;
        }

        .header .version {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 700;
            margin-left: 15px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 18px;
            margin-bottom: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.98);
            padding: 22px;
            border-radius: 14px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .control-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 28px rgba(0, 0, 0, 0.18);
        }

        .control-panel h3 {
            color: #667eea;
            margin-bottom: 16px;
            font-size: 1.1em;
            font-weight: 700;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.88em;
            color: #444;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 6px;
            background: linear-gradient(to right, #ddd 0%, #667eea 50%, #ddd 100%);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
            transition: transform 0.1s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9em;
            background: white;
            transition: border-color 0.2s;
        }

        .control-group input[type="number"]:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .value-display {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 700;
            margin-left: 10px;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 18px;
        }

        button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-weight: 700;
            font-size: 0.92em;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #555;
        }

        .btn-secondary:hover {
            background: #e8e8e8;
        }

        .viz-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(550px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.98);
            padding: 18px;
            border-radius: 14px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 12px;
            font-size: 1.05em;
            font-weight: 700;
        }

        .plot-container {
            width: 100%;
            height: 420px;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.98);
            padding: 18px 24px;
            border-radius: 14px;
            margin: 20px 0;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            align-items: center;
        }

        .status-item {
            font-size: 0.92em;
        }

        .status-label {
            font-weight: 700;
            color: #667eea;
            margin-right: 8px;
        }

        .status-value {
            font-weight: 600;
            color: #333;
        }

        .region-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }

        .region-btn {
            padding: 10px 8px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.82em;
            font-weight: 600;
            transition: all 0.2s;
            text-align: center;
        }

        .region-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }

        .region-btn:hover:not(.active) {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .info-box {
            background: #f0f7ff;
            border-left: 4px solid #3498db;
            padding: 12px 16px;
            border-radius: 6px;
            margin-top: 12px;
            font-size: 0.88em;
            color: #2c3e50;
        }

        /* TF.js Widget specific styles */
        .tf-hyperparams {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tf-hyperparams label {
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tf-hyperparams input[type="number"] {
            width: 60px;
            padding: 6px 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.88em;
        }

        .tf-hyperparams input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .tf-button-row {
            background: rgba(255, 255, 255, 0.98);
            padding: 18px 22px;
            border-radius: 14px;
            margin-bottom: 20px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .tf-button-row h3 {
            color: #667eea;
            margin-bottom: 14px;
            font-size: 1.1em;
            font-weight: 700;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .tf-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .tf-buttons button {
            flex: 1;
            min-width: 120px;
            padding: 12px 16px;
        }

        .tf-progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 12px;
            display: none;
        }

        .tf-progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.2s ease;
        }

        .tf-metrics {
            display: none;
            margin-top: 12px;
            padding: 14px;
            background: #f0f7ff;
            border-left: 4px solid #3498db;
            border-radius: 6px;
            font-size: 0.86em;
        }

        .tf-metrics-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .tf-metrics-values {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .tf-metrics-values span {
            font-family: 'Courier New', monospace;
        }

        @media (max-width: 768px) {

            .controls-grid,
            .viz-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.6em;
            }

            .status-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .tf-hyperparams {
                flex-direction: column;
                align-items: flex-start;
            }

            .tf-buttons {
                flex-direction: column;
            }

            .tf-buttons button {
                width: 100%;
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .running {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>

<body>
    <div class="dashboard">
        <div class="header">
            <h1>üß† DCD 4.0 Interactive Dashboard<span class="version">v0.3.3 BETA</span></h1>
            <p class="subtitle">Differentiable Consciousness Dynamics ‚Äî –ú–µ—Ö–∞–Ω–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å —Å–æ–∑–Ω–∞–Ω–∏—è —Å –ø–æ–ª–Ω–æ–π
                –∫–∞—É–∑–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –∏ —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏</p>
        </div>
        <div class="controls-grid">
            <!-- Causal Weights -->
            <div class="control-panel">
                <h3>‚ö° –ö–∞—É–∑–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞</h3>
                <div class="control-group">
                    <label>w_LC (L‚ÜíC): <span class="value-display" id="val-wLC">0.58</span></label>
                    <input type="range" id="wLC" min="0.3" max="0.9" step="0.01" value="0.58">
                </div>
                <div class="control-group">
                    <label>w_CL (C‚ÜíL): <span class="value-display" id="val-wCL">0.28</span></label>
                    <input type="range" id="wCL" min="0.1" max="0.5" step="0.01" value="0.28">
                </div>
                <div class="control-group">
                    <label>w_LS (L‚ÜíS): <span class="value-display" id="val-wLS">0.72</span></label>
                    <input type="range" id="wLS" min="0.4" max="1.0" step="0.01" value="0.72">
                </div>
                <div class="control-group">
                    <label>w_SL (S‚ÜíL): <span class="value-display" id="val-wSL">0.18</span></label>
                    <input type="range" id="wSL" min="0.1" max="0.4" step="0.01" value="0.18">
                </div>
                <div class="control-group">
                    <label>w_CS (C‚ÜíS): <span class="value-display" id="val-wCS">0.53</span></label>
                    <input type="range" id="wCS" min="0.3" max="0.7" step="0.01" value="0.53">
                </div>
                <div class="control-group">
                    <label>w_SC (S‚ÜíC): <span class="value-display" id="val-wSC">0.42</span></label>
                    <input type="range" id="wSC" min="0.2" max="0.6" step="0.01" value="0.42">
                </div>
            </div>
            <!-- Ignition & Binding -->
            <div class="control-panel">
                <h3>üî• Ignition & Binding</h3>
                <div class="control-group">
                    <label>k_ign: <span class="value-display" id="val-kign">2.3</span></label>
                    <input type="range" id="kign" min="1.0" max="3.0" step="0.1" value="2.3">
                </div>
                <div class="control-group">
                    <label>L_thresh: <span class="value-display" id="val-Lthresh">3.4</span></label>
                    <input type="range" id="Lthresh" min="2.5" max="4.5" step="0.1" value="3.4">
                </div>
                <div class="control-group">
                    <label>Œ±_att: <span class="value-display" id="val-alphaAtt">0.5</span></label>
                    <input type="range" id="alphaAtt" min="0" max="1" step="0.05" value="0.5">
                </div>
                <div class="control-group">
                    <label>k_bind: <span class="value-display" id="val-kbind">0.05</span></label>
                    <input type="range" id="kbind" min="0" max="0.2" step="0.01" value="0.05">
                </div>
            </div>
            <!-- Self & Metacognition -->
            <div class="control-panel">
                <h3>üé≠ Self & Metacognition</h3>
                <div class="control-group">
                    <label>L_crit: <span class="value-display" id="val-Lcrit">4.0</span></label>
                    <input type="range" id="Lcrit" min="3.0" max="5.0" step="0.1" value="4.0">
                </div>
                <div class="control-group">
                    <label>Œ≤_intero: <span class="value-display" id="val-betaIntero">0.5</span></label>
                    <input type="range" id="betaIntero" min="0" max="1" step="0.05" value="0.5">
                </div>
                <div class="control-group">
                    <label>Œ±_agency: <span class="value-display" id="val-alphaAgency">0.10</span></label>
                    <input type="range" id="alphaAgency" min="0" max="0.3" step="0.01" value="0.10">
                </div>
                <div class="control-group">
                    <label>Œ±_psych: <span class="value-display" id="val-alphaPsych">4.8</span></label>
                    <input type="range" id="alphaPsych" min="0" max="10" step="0.1" value="4.8">
                </div>
            </div>
            <!-- Spatial Coupling & Decay -->
            <div class="control-panel">
                <h3>üåä Spatial Coupling & Decay</h3>
                <div class="control-group">
                    <label>D_L: <span class="value-display" id="val-DL">0.05</span></label>
                    <input type="range" id="DL" min="0" max="0.2" step="0.01" value="0.05">
                </div>
                <div class="control-group">
                    <label>D_C: <span class="value-display" id="val-DC">0.15</span></label>
                    <input type="range" id="DC" min="0" max="0.3" step="0.01" value="0.15">
                </div>
                <div class="control-group">
                    <label>D_S: <span class="value-display" id="val-DS">0.02</span></label>
                    <input type="range" id="DS" min="0" max="0.1" step="0.01" value="0.02">
                </div>
                <div class="control-group">
                    <label>Œ¥_C: <span class="value-display" id="val-deltaC">0.5</span></label>
                    <input type="range" id="deltaC" min="0.1" max="1.0" step="0.05" value="0.5">
                </div>
            </div>
            <!-- Neuromodulators -->
            <div class="control-panel">
                <h3>üíä Neuromodulators</h3>
                <div class="control-group">
                    <label>ACh: <span class="value-display" id="val-ACh">1.0</span></label>
                    <input type="range" id="ACh" min="0" max="2" step="0.1" value="1.0">
                </div>
                <div class="control-group">
                    <label>NE: <span class="value-display" id="val-NE">1.0</span></label>
                    <input type="range" id="NE" min="0" max="2" step="0.1" value="1.0">
                </div>
                <div class="control-group">
                    <label>Orexin: <span class="value-display" id="val-Orx">1.0</span></label>
                    <input type="range" id="Orx" min="0" max="2" step="0.1" value="1.0">
                </div>
                <div class="info-box">
                    üí° Psilocybin –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏—è –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (PK model) –¥–ª—è —Å—Ü–µ–Ω–∞—Ä–∏—è "Psychedelic"
                </div>
            </div>

            <!-- Simulation Settings -->
            <div class="control-panel">
                <h3>‚öôÔ∏è Simulation Settings</h3>
                <div class="control-group">
                    <label>Scenario:</label>
                    <select id="scenario">
                        <option value="wake">Wake (baseline)</option>
                        <option value="N2">N2 Sleep</option>
                        <option value="N3">N3 Deep Sleep</option>
                        <option value="propofol">Propofol Anesthesia</option>
                        <option value="psychedelic">Psychedelic (Psilocybin)</option>
                        <option value="meditation">Meditation</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Duration (min): <span class="value-display" id="val-duration">60</span></label>
                    <input type="range" id="duration" min="10" max="360" step="10" value="60">
                </div>
                <div class="control-group">
                    <label>Time step (ms):</label>
                    <input type="number" id="dt" min="1" max="100" value="10">
                </div>
                <div class="button-group">
                    <button class="btn-primary" onclick="runSimulation()">‚ñ∂ Run</button>
                    <button class="btn-secondary" onclick="resetParams()">‚Üª Reset</button>
                    <button class="btn-secondary" id="exportJsonBtn" onclick="exportJSON()">‚¨áÔ∏è Export</button>
                </div>
            </div>

            <!-- ML Hyperparameters -->
            <div class="control-panel">
                <h3>ü§ñ ML Hyperparameters</h3>
                <div class="control-group">
                    <label>Epochs:</label>
                    <input type="number" id="tfEpochs" min="5" max="50" value="18">
                </div>
                <div class="control-group">
                    <label>Batch Size:</label>
                    <input type="number" id="tfBatch" min="8" max="64" step="8" value="24">
                </div>
                <div class="control-group">
                    <label>Learning Rate:</label>
                    <input type="number" id="tfLR" min="0.0001" max="0.01" step="0.0001" value="0.001">
                </div>
                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="tfAugment" checked style="width: 18px; height: 18px;">
                        Data Augmentation
                    </label>
                </div>
                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="tfNormalize" checked style="width: 18px; height: 18px;">
                        Z-score Normalization
                    </label>
                </div>
            </div>
        </div>

        <!-- Region Selection -->
        <div class="control-panel">
            <h3>üó∫Ô∏è Region Selection (13 HCP regions)</h3>
            <div class="region-selector" id="regionSelector"></div>
        </div>

        <!-- Visualizations -->
        <div class="viz-grid">
            <div class="viz-panel">
                <h3>üìà 3D Trajectory (L, C, S)</h3>
                <div id="plot3D" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üìä Time Series</h3>
                <div id="plotTimeSeries" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üî• Regional Heatmap (L)</h3>
                <div id="plotHeatmap" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üß© DMN vs Non-DMN Self</h3>
                <div id="plotDMN" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üéØ Phase Portrait (L-C)</h3>
                <div id="plotPhase" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>‚ö° Causal Network</h3>
                <div id="plotNetwork" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üíä Neuromodulator Dynamics</h3>
                <div id="plotMods" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üëÅÔ∏è Attention Evolution</h3>
                <div id="plotAttention" class="plot-container"></div>
            </div>

        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span class="status-label">Status:</span>
                <span class="status-value" id="statusText">Ready</span>
            </div>
            <div class="status-item">
                <span class="status-label">Clinical State:</span>
                <span class="status-value" id="clinicalState">--</span>
            </div>
            <div class="status-item">
                <span class="status-label">PCI estimate:</span>
                <span class="status-value" id="pciValue">--</span>
            </div>
            <div class="status-item">
                <span class="status-label">S_DMN:</span>
                <span class="status-value" id="sDMNValue">--</span>
            </div>
            <div class="status-item">
                <span class="status-label">S_aINS:</span>
                <span class="status-value" id="saINSValue">--</span>
            </div>
        </div>

        <!-- ML Controls (full width) -->
        <div class="tf-button-row">
            <h3>ü§ñ ML (TensorFlow.js) ‚Äî Real-time Inference (ENHANCED v2.0)</h3>
            <div class="tf-buttons">
                <button class="btn-primary" id="tfTrainBtn">‚ñ∂ Train model</button>
                <button class="btn-secondary" id="tfInferBtn">üîÆ Infer</button>
                <button class="btn-secondary" id="tfImportanceBtn">üîç Importance</button>
                <button class="btn-secondary" id="tfExportBtn">‚¨áÔ∏è Export</button>
                <button class="btn-secondary" id="tfClearBtn">üóëÔ∏è Clear</button>
            </div>
            <div class="tf-progress-bar" id="tfProgressBar">
                <div class="tf-progress-fill" id="tfProgressFill"></div>
            </div>
            <div class="info-box" id="tfLog" style="margin-top: 12px; min-height: 52px;">
                ‚úÖ ML widget ready ‚Äî configure hyperparameters, then press ¬´Train model¬ª
            </div>
            <div class="tf-metrics" id="tfMetrics">
                <div class="tf-metrics-title">Training Metrics (last epoch)</div>
                <div class="tf-metrics-values">
                    <span><strong>Train:</strong> loss=<span id="tfTrainLoss">--</span>, acc=<span
                            id="tfTrainAcc">--</span></span>
                    <span><strong>Val:</strong> loss=<span id="tfValLoss">--</span>, acc=<span
                            id="tfValAcc">--</span></span>
                </div>
            </div>
        </div>

        <!-- Visualizations -->
        <div class="viz-grid">

            <!-- ML Visualizations -->
            <div class="viz-panel">
                <h3>üìâ Training Progress</h3>
                <div id="tfPlotTraining" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üé≤ Predicted State Probabilities</h3>
                <div id="tfPlotProbs" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üß¨ Latent Space (raw)</h3>
                <div id="tfPlotLatent" class="plot-container"></div>
            </div>
            <div class="viz-panel">
                <h3>üî¨ Feature Importance (L¬≤-norm of weights)</h3>
                <div id="tfPlotImportance" class="plot-container"></div>
            </div>
        </div>

    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const REGIONS = ['V1', 'V4', 'MT', 'IT', 'dlPFC', 'rlPFC', 'ACC', 'IPS', 'aINS', 'PCC', 'Claustrum', 'Pulvinar', 'SC'];
        const DMN_INDICES = [4, 5, 9]; // dlPFC, rlPFC, PCC
        const FPN_INDICES = [4, 5, 6, 7]; // dlPFC, rlPFC, ACC, IPS
        const VISUAL_INDICES = [0, 1, 2, 3]; // V1, V4, MT, IT
        const aINS_INDEX = 8;

        // Regional receptor gains (Palomero-Gallagher & Zilles, 2018)
        const RECEPTOR_GAINS = {
            V1: { ACh: 1.2, NE: 0.8, Orx: 0.9 },
            V4: { ACh: 1.3, NE: 0.9, Orx: 0.9 },
            MT: { ACh: 1.1, NE: 1.0, Orx: 0.9 },
            IT: { ACh: 1.4, NE: 1.0, Orx: 1.0 },
            dlPFC: { ACh: 1.5, NE: 1.5, Orx: 1.2 },
            rlPFC: { ACh: 1.4, NE: 1.3, Orx: 1.1 },
            ACC: { ACh: 1.3, NE: 1.4, Orx: 1.2 },
            IPS: { ACh: 1.2, NE: 1.1, Orx: 1.0 },
            aINS: { ACh: 0.5, NE: 1.0, Orx: 0.7 },
            PCC: { ACh: 1.1, NE: 0.9, Orx: 1.0 },
            Claustrum: { ACh: 1.0, NE: 1.0, Orx: 1.0 },
            Pulvinar: { ACh: 0.8, NE: 1.2, Orx: 0.9 },
            SC: { ACh: 0.9, NE: 1.3, Orx: 1.0 }
        };

        let selectedRegions = [0, 4, 5, 8, 9];
        let currentSolution = null;

        // ==================== SCENARIO PRESETS ====================
        const SCENARIO_PRESETS = {
            wake: {
                L: 8.0, C: 7.5, S: 7.5, A: 0.3,
                ACh: 1.0, NE: 1.0, Orx: 1.0,
                w_LC: 0.58, w_CL: 0.28, w_LS: 0.72, w_SL: 0.18, w_CS: 0.53, w_SC: 0.42,
                k_ign: 5.0, L_thresh: 3.4, alpha_att: 0.5, k_bind: 0.05,  // k_ign —É–≤–µ–ª–∏—á–µ–Ω
                L_crit: 4.0, beta_intero: 0.5, alpha_agency: 0.10, alpha_psych: 4.8,
                D_L: 0.10, D_C: 0.30, D_S: 0.05, delta_C: 0.5,  // —É–≤–µ–ª–∏—á–µ–Ω—ã –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–∏—Ñ—Ñ—É–∑–∏–∏
                duration: 60,
                description: 'Resting wakefulness with eyes closed'
            },

            N2: {
                L: 4.5, C: 3.5, S: 2.0, A: 0.1,
                ACh: 0.4, NE: 0.5, Orx: 0.4,
                w_LC: 0.35, w_CL: 0.15, w_LS: 0.50, w_SL: 0.10, w_CS: 0.35, w_SC: 0.25,  // —Å–Ω–∏–∂–µ–Ω—ã –≤–µ—Å–∞
                k_ign: 3.5, L_thresh: 4.5, alpha_att: 0.2, k_bind: 0.02,  // –ø–æ—Ä–æ–≥ –ø–æ–¥–Ω—è—Ç
                L_crit: 5.0, beta_intero: 0.2, alpha_agency: 0.03, alpha_psych: 4.8,
                D_L: 0.05, D_C: 0.12, D_S: 0.02, delta_C: 0.7,  // decay —É–≤–µ–ª–∏—á–µ–Ω
                duration: 90,
                description: 'Light sleep (N2) with sleep spindles'
            },

            N3: {
                L: 2.5, C: 1.5, S: 0.8, A: 0.05,  // –µ—â—ë –Ω–∏–∂–µ baseline
                ACh: 0.25, NE: 0.35, Orx: 0.25,  // —Å–∏–ª—å–Ω–µ–µ –ø–æ–¥–∞–≤–ª–µ–Ω—ã
                w_LC: 0.25, w_CL: 0.10, w_LS: 0.35, w_SL: 0.06, w_CS: 0.25, w_SC: 0.15,  // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–≤—è–∑–Ω–æ—Å—Ç—å
                k_ign: 2.5, L_thresh: 5.0, alpha_att: 0.1, k_bind: 0.01,
                L_crit: 5.5, beta_intero: 0.15, alpha_agency: 0.02, alpha_psych: 4.8,
                D_L: 0.03, D_C: 0.08, D_S: 0.01, delta_C: 0.85,  // –æ—á–µ–Ω—å –±—ã—Å—Ç—Ä—ã–π decay
                duration: 120,
                description: 'Deep sleep (N3/SWS) with slow waves'
            },

            propofol: {
                L: 3.2, C: 2.2, S: 1.2, A: 0.08,  // –±–ª–∏–∑–∫–æ –∫ LOC threshold
                ACh: 0.45, NE: 0.55, Orx: 0.45,
                w_LC: 0.30, w_CL: 0.12, w_LS: 0.40, w_SL: 0.08, w_CS: 0.28, w_SC: 0.20,
                k_ign: 3.0, L_thresh: 4.8, alpha_att: 0.15, k_bind: 0.015,
                L_crit: 5.2, beta_intero: 0.18, alpha_agency: 0.025, alpha_psych: 4.8,
                D_L: 0.04, D_C: 0.10, D_S: 0.015, delta_C: 0.75,
                duration: 60,
                description: 'Propofol anesthesia (moderate sedation)'
            },

            psychedelic: {
                L: 9.0, C: 9.0, S: 7.0, A: 0.5,  // S baseline –≤—ã—à–µ (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø–∞–¥–µ–Ω–∏—è)
                ACh: 1.2, NE: 1.2, Orx: 1.1,
                w_LC: 0.65, w_CL: 0.35, w_LS: 0.80, w_SL: 0.22, w_CS: 0.60, w_SC: 0.50,
                k_ign: 6.0, L_thresh: 2.8, alpha_att: 0.7, k_bind: 0.10,  // –ø–æ—Ä–æ–≥ —Å–Ω–∏–∂–µ–Ω, k_ign –≤—ã—à–µ
                L_crit: 3.2, beta_intero: 0.7, alpha_agency: 0.20, alpha_psych: 8.5,  // alpha_psych —É–≤–µ–ª–∏—á–µ–Ω
                D_L: 0.15, D_C: 0.40, D_S: 0.08, delta_C: 0.35,  // –≤—ã—Å–æ–∫–∞—è –¥–∏—Ñ—Ñ—É–∑–∏—è
                duration: 360,
                description: 'Psilocybin (20mg) with PK model (T_max=90min)'
            },

            meditation: {
                L: 7.5, C: 5.5, S: 8.5, A: 0.7,
                ACh: 0.95, NE: 0.85, Orx: 0.95,
                w_LC: 0.48, w_CL: 0.22, w_LS: 0.78, w_SL: 0.20, w_CS: 0.58, w_SC: 0.48,
                k_ign: 4.5, L_thresh: 3.6, alpha_att: 0.75, k_bind: 0.045,
                L_crit: 3.5, beta_intero: 0.75, alpha_agency: 0.06, alpha_psych: 4.8,
                D_L: 0.08, D_C: 0.18, D_S: 0.06, delta_C: 0.42,
                duration: 60,
                description: 'Vipassana meditation (sustained attention)'
            }
        };

        // ==================== INITIALIZATION ====================
        function initRegionSelector() {
            const container = document.getElementById('regionSelector');
            REGIONS.forEach((region, idx) => {
                const btn = document.createElement('button');
                btn.className = 'region-btn' + (selectedRegions.includes(idx) ? ' active' : '');
                btn.textContent = region;
                btn.onclick = () => toggleRegion(idx, btn);
                container.appendChild(btn);
            });
        }

        function toggleRegion(idx, btn) {
            const pos = selectedRegions.indexOf(idx);
            if (pos > -1) {
                selectedRegions.splice(pos, 1);
                btn.classList.remove('active');
            } else {
                selectedRegions.push(idx);
                btn.classList.add('active');
            }
            if (currentSolution) updateVisualizations();
        }

        // Update value displays
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const valSpan = document.getElementById('val-' + e.target.id);
                if (valSpan) {
                    const val = parseFloat(e.target.value);
                    valSpan.textContent = val.toFixed(2);
                }

                if (['wLC', 'wCL', 'wLS', 'wSL', 'wCS', 'wSC'].includes(e.target.id) && currentSolution) {
                    plotCausalNetwork();
                }
            });
        });

        // Scenario change ‚Üí apply full preset
        document.getElementById('scenario').addEventListener('change', function (e) {
            const scenario = e.target.value;
            if (scenario === 'custom') return;

            const preset = SCENARIO_PRESETS[scenario];
            if (!preset) return;

            const paramMap = {
                wLC: 'w_LC', wCL: 'w_CL', wLS: 'w_LS', wSL: 'w_SL', wCS: 'w_CS', wSC: 'w_SC',
                kign: 'k_ign', Lthresh: 'L_thresh', alphaAtt: 'alpha_att', kbind: 'k_bind',
                Lcrit: 'L_crit', betaIntero: 'beta_intero', alphaAgency: 'alpha_agency', alphaPsych: 'alpha_psych',
                DL: 'D_L', DC: 'D_C', DS: 'D_S', deltaC: 'delta_C',
                ACh: 'ACh', NE: 'NE', Orx: 'Orx',
                duration: 'duration'
            };

            for (const [elemId, presetKey] of Object.entries(paramMap)) {
                const elem = document.getElementById(elemId);
                if (elem && preset[presetKey] !== undefined) {
                    elem.value = preset[presetKey];
                    const valSpan = document.getElementById('val-' + elemId);
                    if (valSpan) valSpan.textContent = preset[presetKey].toFixed(2);
                }
            }

            document.getElementById('statusText').textContent = `‚úì Preset "${scenario}" loaded: ${preset.description}`;
        });

        // ==================== STRUCTURAL CONNECTIVITY ====================
        function createSC() {
            const n = 13;
            const SC = Array(n).fill(0).map(() => Array(n).fill(0));

            // Visual stream
            SC[0][1] = SC[1][0] = 0.80; SC[0][2] = SC[2][0] = 0.60; SC[1][3] = SC[3][1] = 0.75;
            SC[2][3] = SC[3][2] = 0.50; SC[1][2] = SC[2][1] = 0.45;

            // Frontal
            SC[4][5] = SC[5][4] = 0.65; SC[4][6] = SC[6][4] = 0.70; SC[5][6] = SC[6][5] = 0.55;

            // Parietal-Frontal
            SC[4][7] = SC[7][4] = 0.60; SC[5][7] = SC[7][5] = 0.50; SC[6][7] = SC[7][6] = 0.55;

            // Visual-Frontal
            SC[3][4] = SC[4][3] = 0.50; SC[2][7] = SC[7][2] = 0.65; SC[7][1] = SC[1][7] = 0.45;

            // DMN
            SC[4][9] = SC[9][4] = 0.55; SC[5][9] = SC[9][5] = 0.65; SC[8][9] = SC[9][8] = 0.50;
            SC[6][9] = SC[9][6] = 0.45;

            // Insula
            SC[8][6] = SC[6][8] = 0.60; SC[8][4] = SC[4][8] = 0.40;

            // Claustrum broad
            for (let i = 0; i < 10; i++) { SC[10][i] = SC[i][10] = 0.35; }
            SC[10][10] = 0;

            // Pulvinar
            SC[11][7] = SC[7][11] = 0.65; SC[11][1] = SC[1][11] = 0.50; SC[11][6] = SC[6][11] = 0.45;

            // SC
            SC[12][0] = SC[0][12] = 0.55; SC[12][7] = SC[7][12] = 0.50; SC[12][11] = SC[11][12] = 0.40;

            return SC;
        }

        function graphLaplacian(X, SC, D) {
            const n = X.length;
            const result = Array(n).fill(0);
            for (let i = 0; i < n; i++) {
                let sum = 0, deg = 0;
                for (let j = 0; j < n; j++) {
                    sum += SC[i][j] * X[j];
                    deg += SC[i][j];
                }
                result[i] = D * (sum - deg * X[i]);
            }
            return result;
        }

        // ==================== MATH HELPERS ====================
        function sigmoid(x) {
            return x >= 0 ? 1 / (1 + Math.exp(-x)) : Math.exp(x) / (1 + Math.exp(x));
        }

        function heaviside(x) { return x > 0 ? 1 : 0; }

        function clip(x, min, max) {
            return Math.max(min, Math.min(max, x));
        }

        // ==================== PHARMACOKINETICS ====================
        function psilocybinConcentration(t) {
            // Hasler et al. (2004): T_max ‚âà 90 min, T_1/2 ‚âà 180 min
            const T_onset = 30;   // –Ω–∞—á–∞–ª–æ –¥–µ–π—Å—Ç–≤–∏—è
            const T_max = 90;     // –ø–∏–∫
            const T_half = 180;   // –ø–µ—Ä–∏–æ–¥ –ø–æ–ª—É–≤—ã–≤–µ–¥–µ–Ω–∏—è
            const k_elim = Math.log(2) / T_half;

            if (t < T_onset) return 0;

            if (t < T_max) {
                // –ù–µ–ª–∏–Ω–µ–π–Ω—ã–π —Ä–æ—Å—Ç (Hill-–ø–æ–¥–æ–±–Ω–∞—è –∫—Ä–∏–≤–∞—è)
                const progress = (t - T_onset) / (T_max - T_onset);
                return Math.pow(progress, 1.5);  // –Ω–µ–ª–∏–Ω–µ–π–Ω–æ—Å—Ç—å
            } else {
                // –ë–∏—ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Ä–∞—Å–ø–∞–¥ (–±—ã—Å—Ç—Ä–∞—è + –º–µ–¥–ª–µ–Ω–Ω–∞—è —Ñ–∞–∑—ã)
                const t_elapsed = t - T_max;
                const fast_component = 0.7 * Math.exp(-k_elim * 1.5 * t_elapsed);  // –±—ã—Å—Ç—Ä–∞—è —Ñ–∞–∑–∞
                const slow_component = 0.3 * Math.exp(-k_elim * 0.5 * t_elapsed);  // –º–µ–¥–ª–µ–Ω–Ω–∞—è —Ñ–∞–∑–∞
                return fast_component + slow_component;
            }
        }

        // ==================== –í–†–ï–ú–ï–ù–ù–ê–Ø –ú–û–î–£–õ–Ø–¶–ò–Ø ====================
        function computeCircadianDrive(t) {
            // –°–∏–Ω—É—Å–æ–∏–¥–∞–ª—å–Ω–∞—è –º–æ–¥—É–ª—è—Ü–∏—è —Å –º–∏–Ω–∏–º—É–º–æ–º –≤ 3 AM, –º–∞–∫—Å–∏–º—É–º–æ–º –≤ 3 PM
            // t –≤ –º–∏–Ω—É—Ç–∞—Ö –æ—Ç –Ω–∞—á–∞–ª–∞ —Å–∏–º—É–ª—è—Ü–∏–∏; –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —Å—Ç–∞—Ä—Ç –≤ 9 AM
            const hour_of_day = 9 + (t / 60) % 24;
            const phase = (hour_of_day - 15) * Math.PI / 12;  // —Å–¥–≤–∏–≥ —Ñ–∞–∑—ã –¥–ª—è –ø–∏–∫–∞ –≤ 15:00
            return 0.5 + 0.5 * Math.sin(phase);
        }

        function computeSleepPressure(t, scenario) {
            // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ sleep pressure –≤–æ –≤—Ä–µ–º—è –±–æ–¥—Ä—Å—Ç–≤–æ–≤–∞–Ω–∏—è
            if (['N2', 'N3', 'propofol'].includes(scenario)) {
                return 0.9;  // –≤—ã—Å–æ–∫–∏–π sleep pressure
            }

            const tau_sleep = 16 * 60;  // –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è (16 —á–∞—Å–æ–≤)
            return 1.0 - Math.exp(-t / tau_sleep);
        }

        function computeNeuromodulators(t, scenario, base_ACh, base_NE, base_Orx) {
            const circadian = computeCircadianDrive(t);
            const sleep_pressure = computeSleepPressure(t, scenario);

            let ACh, NE, Orx;

            if (['N2', 'N3'].includes(scenario)) {
                // –°–∏–ª—å–Ω–æ–µ –ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ –≤–æ —Å–Ω–µ
                ACh = base_ACh * (0.3 + 0.2 * circadian) * (1 - sleep_pressure * 0.6);
                NE = base_NE * (0.35 + 0.15 * circadian) * (1 - sleep_pressure * 0.5);
                Orx = base_Orx * (0.25 + 0.2 * circadian) * (1 - sleep_pressure * 0.7);
            } else if (scenario === 'propofol') {
                // –§–∞—Ä–º–∞–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–µ –ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ (—Å—Ç–∞–±–∏–ª—å–Ω–æ–µ)
                ACh = base_ACh * 0.45;
                NE = base_NE * 0.55;
                Orx = base_Orx * 0.45;
            } else {
                // Wake/psychedelic/meditation: —Ü–∏—Ä–∫–∞–¥–Ω–∞—è –º–æ–¥—É–ª—è—Ü–∏—è
                ACh = base_ACh * (0.8 + 0.2 * circadian);
                NE = base_NE * (0.85 + 0.15 * circadian);
                Orx = base_Orx * (0.9 + 0.1 * circadian) * (1 - sleep_pressure * 0.3);
            }

            return { ACh, NE, Orx };
        }

        // ==================== DYNAMICS ====================
        function computeL_target(ACh, NE, Orx, region_idx) {
            const region = REGIONS[region_idx];
            const gains = RECEPTOR_GAINS[region];

            // –±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å
            const z = 3.0 * gains.ACh * ACh +
                2.5 * gains.NE * NE +
                3.5 * gains.Orx * Orx - 6.0;  // –ø–æ–≤—ã—à–µ–Ω –ø–æ—Ä–æ–≥

            return 10 * sigmoid(z);
        }

        function computeSensoryInput(region_idx, A_i, scenario) {
            if (VISUAL_INDICES.includes(region_idx)) {
                if (scenario === 'psychedelic') return 0.9 * A_i;  // —É–≤–µ–ª–∏—á–µ–Ω
                if (scenario === 'wake') return 0.5 * A_i;
                if (scenario === 'meditation') return 0.35 * A_i;
                return 0.15 * A_i;  // sleep/anesthesia
            } else {
                return 0.08 * A_i;
            }
        }

        function computeDerivatives(state, params, SC, t, scenario) {
            const n = state.L.length;
            const dL = Array(n).fill(0);
            const dC = Array(n).fill(0);
            const dS = Array(n).fill(0);
            const dA = Array(n).fill(0);

            // –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–æ–¥—É–ª—è—Ü–∏—è –Ω–µ–π—Ä–æ–º–æ–¥—É–ª—è—Ç–æ—Ä–æ–≤
            const mods = computeNeuromodulators(t, scenario, params.ACh, params.NE, params.Orx);

            // Psilocybin concentration (time-dependent)
            const psiloConc = scenario === 'psychedelic' ? psilocybinConcentration(t) : 0;

            for (let i = 0; i < n; i++) {
                const L_target = computeL_target(mods.ACh, mods.NE, mods.Orx, i);

                // dL/dt (–±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è)
                dL[i] = 0.6 * state.L[i] * (1 - state.L[i] / 10) +  // homeostasis
                    0.8 * (L_target - state.L[i]) +            // –±—ã—Å—Ç—Ä–µ–µ —Å—Ö–æ–¥–∏–º–æ—Å—Ç—å –∫ target
                    params.w_CL * state.C[i] +
                    params.w_SL * state.S[i];

                // Ignition (–±–æ–ª–µ–µ —Ä–µ–∑–∫–∏–π –ø–µ—Ä–µ—Ö–æ–¥)
                const L_thresh_eff = params.L_thresh * (1 - params.alpha_att * state.A[i]);
                const h_ign = sigmoid(params.k_ign * (state.L[i] - L_thresh_eff));

                // dC/dt 
                const g_att = Math.exp(-Math.pow(state.C[i] - 7.5, 2) / 12.5);
                const I_sens = computeSensoryInput(i, state.A[i], scenario);

                dC[i] = params.w_LC * state.L[i] * h_ign * (10 - state.C[i]) / 10 +
                    I_sens * 1.2 +  // —É—Å–∏–ª–µ–Ω —Å–µ–Ω—Å–æ—Ä–Ω—ã–π –≤—Ö–æ–¥
                    params.w_SC * state.S[i] * g_att +
                    params.k_bind * state.L[i] * state.C[i] * (10 - state.C[i]) * g_att -
                    params.delta_C * state.C[i];

                // dS/dt (–±–æ–ª–µ–µ —Ä–µ–∑–∫–∏–π –ø–æ—Ä–æ–≥ PFC)
                const H_L = heaviside(state.L[i] - params.L_crit);
                dS[i] = params.w_LS * state.L[i] * H_L +
                    params.w_CS * Math.log(1 + state.C[i]);

                // aINS interoception (—Å–∏–ª—å–Ω–µ–µ)
                if (i === aINS_INDEX) {
                    dS[i] += params.beta_intero * state.L[i] * 1.5 * (1 - state.S[i] / 10);
                }

                // Agency disruption (—É–≤–µ–ª–∏—á–µ–Ω –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç)
                dS[i] -= params.alpha_agency * 1.5 * Math.abs(dC[i]) * state.S[i];

                // DMN-specific psychedelic suppression (–±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π)
                if (DMN_INDICES.includes(i)) {
                    const suppression_factor = params.alpha_psych * psiloConc * state.S[i];
                    dS[i] -= suppression_factor * (1 + 0.5 * psiloConc);  // –Ω–µ–ª–∏–Ω–µ–π–Ω–æ–µ —É—Å–∏–ª–µ–Ω–∏–µ
                }

                // dA/dt (attention)
                const salience = state.C[i] / 10;
                let td_signal = 0;
                for (const j of FPN_INDICES) {
                    td_signal += SC[j][i] * state.S[j] / 10;
                }

                dA[i] = 0.5 * salience * (1 - state.A[i]) +
                    0.3 * td_signal * (1 - state.A[i]) -
                    0.4 * state.A[i];
            }

            // Spatial coupling (—É–≤–µ–ª–∏—á–µ–Ω—ã –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã)
            const dL_spatial = graphLaplacian(state.L, SC, params.D_L);
            const dC_spatial = graphLaplacian(state.C, SC, params.D_C);
            const dS_spatial = graphLaplacian(state.S, SC, params.D_S);

            for (let i = 0; i < n; i++) {
                dL[i] += dL_spatial[i];
                dC[i] += dC_spatial[i];
                dS[i] += dS_spatial[i];

                // –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –¥–ª—è sleep —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤
                if (['N2', 'N3'].includes(scenario)) {
                    dL[i] -= 0.15 * state.L[i];  // –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π decay
                    dC[i] -= 0.20 * state.C[i];
                    dS[i] -= 0.25 * state.S[i];
                }
            }

            return { L: dL, C: dC, S: dS, A: dA };
        }

        // ==================== RK4 INTEGRATION ====================
        function rk4Step(state, dt, params, SC, t, scenario) {
            const k1 = computeDerivatives(state, params, SC, t, scenario);
            const k2 = computeDerivatives(addStates(state, scaleState(k1, dt / 2)), params, SC, t + dt / 2, scenario);
            const k3 = computeDerivatives(addStates(state, scaleState(k2, dt / 2)), params, SC, t + dt / 2, scenario);
            const k4 = computeDerivatives(addStates(state, scaleState(k3, dt)), params, SC, t + dt, scenario);

            const dState = scaleState(addStates(k1, scaleState(addStates(k2, k3), 2), k4), dt / 6);
            return addStates(state, dState);
        }

        function scaleState(state, scalar) {
            return {
                L: state.L.map(x => x * scalar),
                C: state.C.map(x => x * scalar),
                S: state.S.map(x => x * scalar),
                A: state.A.map(x => x * scalar)
            };
        }

        function addStates(...states) {
            const n = states[0].L.length;
            const result = {
                L: Array(n).fill(0),
                C: Array(n).fill(0),
                S: Array(n).fill(0),
                A: Array(n).fill(0)
            };

            states.forEach(state => {
                for (let i = 0; i < n; i++) {
                    result.L[i] += state.L[i];
                    result.C[i] += state.C[i];
                    result.S[i] += state.S[i];
                    result.A[i] += state.A[i];
                }
            });

            return result;
        }

        // ==================== INITIALIZATION ====================
        function initializeState(scenario) {
            const n = 13;
            const preset = SCENARIO_PRESETS[scenario] || SCENARIO_PRESETS.wake;

            const state = {
                L: Array(n).fill(preset.L),
                C: Array(n).fill(preset.C),
                S: Array(n).fill(preset.S),
                A: Array(n).fill(preset.A)
            };

            // Region-specific variations (–±–æ–ª–µ–µ –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–µ)
            for (let i = 0; i < n; i++) {
                // Visual cortex
                if (VISUAL_INDICES.includes(i)) {
                    if (['wake', 'psychedelic'].includes(scenario)) {
                        state.C[i] += 0.3;
                    } else if (['N2', 'N3', 'propofol'].includes(scenario)) {
                        state.C[i] -= 0.2;  // –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ
                    }
                }

                // DMN
                if (DMN_INDICES.includes(i)) {
                    if (['wake', 'meditation'].includes(scenario)) {
                        state.S[i] += 0.2;
                    } else if (scenario === 'psychedelic') {
                        state.S[i] += 0.5;  // –≤—ã—à–µ baseline –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø–∞–¥–µ–Ω–∏—è
                    }
                }

                // aINS preserved in psychedelic
                if (i === aINS_INDEX && scenario === 'psychedelic') {
                    state.S[i] = 6.5;  // –≤—ã—à–µ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ —Å DMN
                }

                // Minimal noise (—Å–Ω–∏–∂–µ–Ω —à—É–º)
                state.L[i] += (Math.random() - 0.5) * 0.15;
                state.C[i] += (Math.random() - 0.5) * 0.15;
                state.S[i] += (Math.random() - 0.5) * 0.10;
                state.A[i] += (Math.random() - 0.5) * 0.05;
            }

            return state;
        }

        // ==================== PARAMETERS ====================
        function getParams() {
            return {
                w_LC: parseFloat(document.getElementById('wLC').value),
                w_CL: parseFloat(document.getElementById('wCL').value),
                w_LS: parseFloat(document.getElementById('wLS').value),
                w_SL: parseFloat(document.getElementById('wSL').value),
                w_CS: parseFloat(document.getElementById('wCS').value),
                w_SC: parseFloat(document.getElementById('wSC').value),
                k_ign: parseFloat(document.getElementById('kign').value),
                L_thresh: parseFloat(document.getElementById('Lthresh').value),
                alpha_att: parseFloat(document.getElementById('alphaAtt').value),
                k_bind: parseFloat(document.getElementById('kbind').value),
                L_crit: parseFloat(document.getElementById('Lcrit').value),
                beta_intero: parseFloat(document.getElementById('betaIntero').value),
                alpha_agency: parseFloat(document.getElementById('alphaAgency').value),
                alpha_psych: parseFloat(document.getElementById('alphaPsych').value),
                D_L: parseFloat(document.getElementById('DL').value),
                D_C: parseFloat(document.getElementById('DC').value),
                D_S: parseFloat(document.getElementById('DS').value),
                delta_C: parseFloat(document.getElementById('deltaC').value),
                ACh: parseFloat(document.getElementById('ACh').value),
                NE: parseFloat(document.getElementById('NE').value),
                Orx: parseFloat(document.getElementById('Orx').value)
            };
        }

        // ==================== SIMULATION ====================
        function runSimulation() {
            try {
                const statusElem = document.getElementById('statusText');
                statusElem.textContent = 'Running...';
                statusElem.classList.add('running');

                const params = getParams();
                const SC = createSC();
                const scenario = document.getElementById('scenario').value;
                const duration = parseFloat(document.getElementById('duration').value);
                const dt = parseFloat(document.getElementById('dt').value) / 1000;
                const steps = Math.floor(duration / dt);

                if (steps > 100000) {
                    alert('‚ö†Ô∏è Too many steps! Increase time step or decrease duration.');
                    statusElem.classList.remove('running');
                    return;
                }

                let state = initializeState(scenario);

                const solution = {
                    t: [0],
                    L: [state.L.slice()],
                    C: [state.C.slice()],
                    S: [state.S.slice()],
                    A: [state.A.slice()],
                    psiloConc: [scenario === 'psychedelic' ? 0 : null],
                    neuromod: [computeNeuromodulators(0, scenario, params.ACh, params.NE, params.Orx)]
                };

                const progressInterval = Math.max(1, Math.floor(steps / 20));

                for (let step = 0; step < steps; step++) {
                    const t = (step + 1) * dt;
                    state = rk4Step(state, dt, params, SC, t, scenario);

                    // Clip
                    state.L = state.L.map(x => clip(x, 0, 10));
                    state.C = state.C.map(x => clip(x, 0, 10));
                    state.S = state.S.map(x => clip(x, 0, 10));
                    state.A = state.A.map(x => clip(x, 0, 1));

                    if (step % 10 === 0) {
                        solution.t.push(t);
                        solution.L.push(state.L.slice());
                        solution.C.push(state.C.slice());
                        solution.S.push(state.S.slice());
                        solution.A.push(state.A.slice());
                        if (scenario === 'psychedelic') {
                            solution.psiloConc.push(psilocybinConcentration(t));
                        }
                        solution.neuromod.push(computeNeuromodulators(t, scenario, params.ACh, params.NE, params.Orx));
                    }

                    if (step % progressInterval === 0 && step > 0) {
                        const progress = Math.round((step / steps) * 100);
                        statusElem.textContent = `Running... ${progress}%`;
                    }
                }

                currentSolution = solution;
                updateVisualizations();
                updateStatus(state, scenario);

                statusElem.textContent = `‚úì Complete (${steps} steps, ${solution.t.length} points)`;
                statusElem.classList.remove('running');

            } catch (error) {
                console.error('Simulation error:', error);
                document.getElementById('statusText').textContent = '‚úó Error: ' + error.message;
                document.getElementById('statusText').classList.remove('running');
            }
        }

        // ==================== VISUALIZATIONS ====================
        function updateVisualizations() {
            if (!currentSolution) return;

            plot3DTrajectory();
            plotTimeSeries();
            plotHeatmap();
            plotDMNComparison();
            plotPhasePortrait();
            plotCausalNetwork();
            plotNeuromodulators();
            plotAttention();
        }

        function plot3DTrajectory() {
            const sol = currentSolution;
            const L_mean = sol.L.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const C_mean = sol.C.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const S_mean = sol.S.map(arr => arr.reduce((a, b) => a + b) / arr.length);

            const trace = {
                type: 'scatter3d',
                mode: 'lines+markers',
                x: L_mean, y: C_mean, z: S_mean,
                line: { color: sol.t, colorscale: 'Viridis', width: 5 },
                marker: { size: 3, color: sol.t, colorscale: 'Viridis' }
            };

            const layout = {
                scene: {
                    xaxis: { title: 'Level (L)', range: [0, 10] },
                    yaxis: { title: 'Content (C)', range: [0, 10] },
                    zaxis: { title: 'Self (S)', range: [0, 10] },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.2 } }
                },
                margin: { l: 0, r: 0, t: 0, b: 0 }
            };

            Plotly.newPlot('plot3D', [trace], layout, { responsive: true });
        }

        function plotTimeSeries() {
            const sol = currentSolution;
            const L_mean = sol.L.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const C_mean = sol.C.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const S_mean = sol.S.map(arr => arr.reduce((a, b) => a + b) / arr.length);

            const traces = [
                { x: sol.t, y: L_mean, name: 'L', line: { color: '#e74c3c', width: 3 } },
                { x: sol.t, y: C_mean, name: 'C', line: { color: '#3498db', width: 3 } },
                { x: sol.t, y: S_mean, name: 'S', line: { color: '#2ecc71', width: 3 } },
                {
                    x: sol.t, y: Array(sol.t.length).fill(3.4), name: 'L_thresh',
                    line: { dash: 'dash', color: 'rgba(0,0,0,0.4)', width: 2 }
                }
            ];

            const layout = {
                xaxis: { title: 'Time (min)' },
                yaxis: { title: 'Value', range: [0, 10] },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { x: 1.02, y: 1, xanchor: 'left' }
            };

            Plotly.newPlot('plotTimeSeries', traces, layout, { responsive: true });
        }

        function plotHeatmap() {
            const sol = currentSolution;
            const L_matrix = sol.L[0].map((_, i) => sol.L.map(arr => arr[i]));

            const trace = {
                type: 'heatmap',
                z: L_matrix,
                x: sol.t,
                y: REGIONS,
                colorscale: 'RdYlBu',
                reversescale: true,
                zmin: 0, zmax: 10,
                colorbar: { title: 'Level (L)' }
            };

            const layout = {
                xaxis: { title: 'Time (min)' },
                yaxis: { title: 'Region' },
                margin: { l: 100, r: 80, t: 30, b: 50 }
            };

            Plotly.newPlot('plotHeatmap', [trace], layout, { responsive: true });
        }

        function plotDMNComparison() {
            const sol = currentSolution;

            const S_DMN = sol.S.map(arr => {
                const dmn = DMN_INDICES.map(i => arr[i]);
                return dmn.reduce((a, b) => a + b) / dmn.length;
            });

            const S_aINS = sol.S.map(arr => arr[aINS_INDEX]);

            const nonDMN = [...Array(13).keys()].filter(i => !DMN_INDICES.includes(i) && i !== aINS_INDEX);
            const S_nonDMN = sol.S.map(arr => {
                const non = nonDMN.map(i => arr[i]);
                return non.reduce((a, b) => a + b) / non.length;
            });

            const traces = [
                { x: sol.t, y: S_DMN, name: 'S_DMN', line: { color: '#9b59b6', width: 3 } },
                { x: sol.t, y: S_aINS, name: 'S_aINS', line: { color: '#e67e22', width: 3 } },
                { x: sol.t, y: S_nonDMN, name: 'S_other', line: { color: '#95a5a6', width: 2 } }
            ];

            const layout = {
                xaxis: { title: 'Time (min)' },
                yaxis: { title: 'Self/Metacognition', range: [0, 10] },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { x: 1.02, y: 1 }
            };

            Plotly.newPlot('plotDMN', traces, layout, { responsive: true });
        }

        function plotPhasePortrait() {
            const sol = currentSolution;
            const L_mean = sol.L.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const C_mean = sol.C.map(arr => arr.reduce((a, b) => a + b) / arr.length);

            const trace = {
                type: 'scatter',
                mode: 'lines+markers',
                x: L_mean, y: C_mean,
                marker: { size: 5, color: sol.t, colorscale: 'Viridis', colorbar: { title: 'Time' } },
                line: { width: 2, color: 'rgba(0,0,0,0.2)' }
            };

            const layout = {
                xaxis: { title: 'Level (L)', range: [0, 10] },
                yaxis: { title: 'Content (C)', range: [0, 10] },
                margin: { l: 60, r: 80, t: 30, b: 50 }
            };

            Plotly.newPlot('plotPhase', [trace], layout, { responsive: true });
        }

        function plotCausalNetwork() {
            const params = getParams();
            const weights = [
                { source: 'L', target: 'C', value: params.w_LC, color: '#3498db' },
                { source: 'C', target: 'L', value: params.w_CL, color: '#e74c3c' },
                { source: 'L', target: 'S', value: params.w_LS, color: '#2ecc71' },
                { source: 'S', target: 'L', value: params.w_SL, color: '#f39c12' },
                { source: 'C', target: 'S', value: params.w_CS, color: '#9b59b6' },
                { source: 'S', target: 'C', value: params.w_SC, color: '#1abc9c' }
            ];

            const positions = {
                L: [0, 1],
                C: [0.866, -0.5],
                S: [-0.866, -0.5]
            };

            const edge_traces = weights.map(w => ({
                type: 'scatter',
                mode: 'lines',
                x: [positions[w.source][0], positions[w.target][0]],
                y: [positions[w.source][1], positions[w.target][1]],
                line: { width: w.value * 12, color: w.color },
                hoverinfo: 'text',
                text: `${w.source}‚Üí${w.target}: ${w.value.toFixed(2)}`,
                showlegend: false
            }));

            const node_trace = {
                type: 'scatter',
                mode: 'markers+text',
                x: [0, 0.866, -0.866],
                y: [1, -0.5, -0.5],
                text: ['L', 'C', 'S'],
                textposition: 'middle center',
                marker: { size: 60, color: '#667eea', line: { width: 3, color: 'white' } },
                textfont: { size: 20, color: 'white', family: 'Arial Black' },
                hoverinfo: 'none'
            };

            const layout = {
                xaxis: { visible: false, range: [-1.5, 1.5] },
                yaxis: { visible: false, range: [-1.5, 1.5] },
                margin: { l: 20, r: 20, t: 20, b: 20 },
                hovermode: 'closest'
            };

            Plotly.newPlot('plotNetwork', [...edge_traces, node_trace], layout, { responsive: true });
        }

        function plotNeuromodulators() {
            const sol = currentSolution;

            // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏–Ω–∞–º–∏–∫—É –∏–∑ solution.neuromod
            const ACh_t = sol.neuromod.map(m => m.ACh);
            const NE_t = sol.neuromod.map(m => m.NE);
            const Orx_t = sol.neuromod.map(m => m.Orx);

            const traces = [
                { x: sol.t, y: ACh_t, name: 'ACh', line: { color: '#3498db', width: 3 } },
                { x: sol.t, y: NE_t, name: 'NE', line: { color: '#e74c3c', width: 3 } },
                { x: sol.t, y: Orx_t, name: 'Orexin', line: { color: '#2ecc71', width: 3 } }
            ];

            if (sol.psiloConc && sol.psiloConc[0] !== null) {
                traces.push({
                    x: sol.t, y: sol.psiloConc,
                    name: 'Psilocybin', line: { color: '#9b59b6', width: 3, dash: 'dot' }
                });
            }

            const layout = {
                xaxis: { title: 'Time (min)' },
                yaxis: { title: 'Concentration (norm.)', range: [0, 2] },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { x: 1.02, y: 1 }
            };

            Plotly.newPlot('plotMods', traces, layout, { responsive: true });
        }

        function plotAttention() {
            const sol = currentSolution;
            const A_mean = sol.A.map(arr => arr.reduce((a, b) => a + b) / arr.length);
            const A_visual = sol.A.map(arr => {
                const vis = VISUAL_INDICES.map(i => arr[i]);
                return vis.reduce((a, b) => a + b) / vis.length;
            });
            const A_frontal = sol.A.map(arr => {
                const fpn = FPN_INDICES.map(i => arr[i]);
                return fpn.reduce((a, b) => a + b) / fpn.length;
            });

            const traces = [
                { x: sol.t, y: A_mean, name: 'Mean', line: { color: '#34495e', width: 3 } },
                { x: sol.t, y: A_visual, name: 'Visual', line: { color: '#3498db', width: 2 } },
                { x: sol.t, y: A_frontal, name: 'FPN', line: { color: '#e74c3c', width: 2 } }
            ];

            const layout = {
                xaxis: { title: 'Time (min)' },
                yaxis: { title: 'Attention', range: [0, 1] },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { x: 1.02, y: 1 }
            };

            Plotly.newPlot('plotAttention', traces, layout, { responsive: true });
        }

        // ==================== STATUS UPDATE ====================
        function updateStatus(state, scenario) {
            const L_mean = state.L.reduce((a, b) => a + b) / state.L.length;
            const S_DMN = DMN_INDICES.map(i => state.S[i]).reduce((a, b) => a + b) / DMN_INDICES.length;
            const S_aINS = state.S[aINS_INDEX];

            // PCI estimate
            const PCI = L_mean / 10;
            document.getElementById('pciValue').textContent = PCI.toFixed(3);

            // Clinical state
            let clinicalState;
            if (L_mean < 2.5) clinicalState = 'üî¥ VS/UWS';
            else if (L_mean < 4.0) clinicalState = 'üü† MCS-';
            else if (L_mean < 5.5) clinicalState = 'üü° MCS+';
            else if (L_mean < 7.0) clinicalState = 'üü¢ EMCS';
            else clinicalState = '‚úÖ Conscious';

            document.getElementById('clinicalState').textContent = clinicalState;

            // S values
            document.getElementById('sDMNValue').textContent = S_DMN.toFixed(2);
            document.getElementById('saINSValue').textContent = S_aINS.toFixed(2);

            // Validation for psychedelic scenario
            if (scenario === 'psychedelic') {
                const dmn_suppressed = S_DMN < 2.5;
                const ains_preserved = S_aINS > 3.5;
                const dmn_ains_diff = S_aINS - S_DMN;

                if (dmn_suppressed && ains_preserved && dmn_ains_diff > 1.5) {
                    document.getElementById('statusText').textContent += ' | ‚úÖ DMN-specific suppression validated';
                } else {
                    document.getElementById('statusText').textContent += ` | ‚ö†Ô∏è Validation: S_DMN=${S_DMN.toFixed(2)}, S_aINS=${S_aINS.toFixed(2)}, Œî=${dmn_ains_diff.toFixed(2)}`;
                }
            }
        }

        // ==================== RESET ====================
        function resetParams() {
            const preset = SCENARIO_PRESETS.wake;

            document.getElementById('scenario').value = 'wake';

            const paramMap = {
                wLC: 'w_LC', wCL: 'w_CL', wLS: 'w_LS', wSL: 'w_SL', wCS: 'w_CS', wSC: 'w_SC',
                kign: 'k_ign', Lthresh: 'L_thresh', alphaAtt: 'alpha_att', kbind: 'k_bind',
                Lcrit: 'L_crit', betaIntero: 'beta_intero', alphaAgency: 'alpha_agency', alphaPsych: 'alpha_psych',
                DL: 'D_L', DC: 'D_C', DS: 'D_S', deltaC: 'delta_C',
                ACh: 'ACh', NE: 'NE', Orx: 'Orx',
                duration: 'duration'
            };

            for (const [elemId, presetKey] of Object.entries(paramMap)) {
                const elem = document.getElementById(elemId);
                if (elem && preset[presetKey] !== undefined) {
                    elem.value = preset[presetKey];
                    const valSpan = document.getElementById('val-' + elemId);
                    if (valSpan) valSpan.textContent = preset[presetKey].toFixed(2);
                }
            }

            document.getElementById('dt').value = 10;
            document.getElementById('statusText').textContent = '‚úì Reset to baseline wake parameters';
        }

        // ==================== JSON EXPORT ====================
        /**
         * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã (–ø–∞—Ä–∞–º–µ—Ç—Ä—ã, solution, —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ)
         * –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç, –≥–æ—Ç–æ–≤—ã–π –∫ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ JSON.
         */
        function getExportObject() {
            const params = getParams();
            const scenario = document.getElementById('scenario').value;
            const duration = parseFloat(document.getElementById('duration').value);
            const dt_ms = parseFloat(document.getElementById('dt').value);
            const SC = createSC();

            const exportObj = {
                metadata: {
                    app: 'DCD 4.0 Dashboard',
                    version: 'v0.3.3 BETA',
                    exported_at: (new Date()).toISOString(),
                    scenario: scenario,
                    duration_min: duration,
                    dt_ms: dt_ms
                },
                regions: REGIONS.slice(),
                receptor_gains: RECEPTOR_GAINS,
                selected_regions: selectedRegions.slice(),
                structural_connectivity: SC,
                params: params,
                // currentSolution –º–æ–∂–µ—Ç –±—ã—Ç—å null (–µ—Å–ª–∏ —Å–∏–º—É–ª—è—Ü–∏—è –Ω–µ –∑–∞–ø—É—Å–∫–∞–ª–∞—Å—å)
                solution: currentSolution ? currentSolution : null,
                scenario_presets: SCENARIO_PRESETS
            };

            return exportObj;
        }

        /**
         * –°–∫–∞—á–∏–≤–∞–µ—Ç JSON-—Ñ–∞–π–ª —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–º –∏–º–µ–Ω–µ–º.
         * –¢–∞–∫–∂–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å JSON –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ).
         */
        function downloadJSON(filename, obj) {
            try {
                const json = JSON.stringify(obj, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);

                // –ü–æ–ø—ã—Ç–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ clipboard (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ)
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(json).then(() => {
                        document.getElementById('statusText').textContent = `‚úì JSON exported & copied to clipboard (${filename})`;
                    }).catch(() => {
                        document.getElementById('statusText').textContent = `‚úì JSON exported (${filename}) ‚Äî clipboard unavailable`;
                    });
                } else {
                    document.getElementById('statusText').textContent = `‚úì JSON exported (${filename})`;
                }
            } catch (err) {
                console.error('Export error:', err);
                document.getElementById('statusText').textContent = '‚úó Error exporting JSON: ' + (err && err.message ? err.message : String(err));
            }
        }

        /**
         * UI-–æ–±—ë—Ä—Ç–∫–∞: —Å–æ–±–∏—Ä–∞–µ—Ç –æ–±—ä–µ–∫—Ç, –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –∏ –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç –∑–∞–≥—Ä—É–∑–∫—É.
         */
        function exportJSON() {
            // –ù–µ–±–æ–ª—å—à–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è: –µ—Å–ª–∏ currentSolution –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const solutionExists = !!currentSolution;
            const exportObj = getExportObject();

            if (!solutionExists) {
                // —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ú—ã –Ω–µ –¥–µ–ª–∞–µ–º ‚Äî –ø—Ä–æ—Å—Ç–æ –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ–º –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                document.getElementById('statusText').textContent = '‚ö†Ô∏è No simulation results yet ‚Äî exporting current parameters only';
            } else {
                document.getElementById('statusText').textContent = 'Exporting JSON...';
            }

            // –ò–º—è —Ñ–∞–π–ª–∞ –≤–∫–ª—é—á–∞–µ—Ç —Å—Ü–µ–Ω–∞—Ä–∏–π –∏ –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏
            const scenario = (exportObj.metadata && exportObj.metadata.scenario) ? exportObj.metadata.scenario : 'custom';
            const ts = (new Date()).toISOString().replace(/[:.]/g, '-');
            const filename = `DCD4.0_export_${scenario}_${ts}.json`;

            downloadJSON(filename, exportObj);
        }


        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', function () {
            initRegionSelector();
            console.log('DCD 4.0 Dashboard BETA v0.3.3');
            console.log('Ready for simulation.');
        });
    </script>



    <script id="tf">
        // ================= ENHANCED TF.JS WIDGET v2.0 =================
        /**
         * Improvements:
         * - Fixed int32/float32 type mismatch (one-hot encoding)
         * - Added memory management (tensor disposal)
         * - Implemented z-score normalization
         * - Added validation split (20%)
         * - Enhanced architecture (deeper bottleneck)
         * - Real-time training curves
         * - Feature importance visualization
         * - Data augmentation toggle
         * - Progress bar & metrics dashboard
         * - Robust error handling
         */

        (async function setupEnhancedTFWidget() {
            if (typeof tf === 'undefined') {
                console.warn('‚ö†Ô∏è TensorFlow.js not loaded.');
                document.getElementById('tfLog').textContent = '‚ùå TensorFlow.js library not available';
                return;
            }

            // ==================== CONFIG ====================
            const TF_WIDGET = {
                windowSize: 32,
                regions: 13,
                featuresPerRegion: 3,
                classes: ['VS/UWS', 'MCS-', 'MCS+', 'EMCS', 'Conscious'],
                model: null,
                normalizer: null, // {mean, std}
                trainingHistory: {
                    loss: [], val_loss: [], acc: [], val_acc: [], pci_mse: [], val_pci_mse: []
                }
            };

            // UI elements
            const trainBtn = document.getElementById('tfTrainBtn');
            const inferBtn = document.getElementById('tfInferBtn');
            const importanceBtn = document.getElementById('tfImportanceBtn');
            const exportBtn = document.getElementById('tfExportBtn');
            const clearBtn = document.getElementById('tfClearBtn');
            const tfLog = document.getElementById('tfLog');
            const tfProgressBar = document.getElementById('tfProgressBar');
            const tfProgressFill = document.getElementById('tfProgressFill');
            const tfMetrics = document.getElementById('tfMetrics');

            // ==================== UTILITIES ====================
            function logTF(msg, type = 'info') {
                const icons = { info: '‚ÑπÔ∏è', success: '‚úÖ', warning: '‚ö†Ô∏è', error: '‚ùå' };
                tfLog.textContent = `${icons[type] || ''} ${msg}`;
                console.log('[TFWidget]', msg);
            }

            function updateProgress(percent) {
                tfProgressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            }

            function updateMetrics(logs) {
                tfMetrics.style.display = 'block';
                document.getElementById('tfTrainLoss').textContent = (logs.loss || 0).toFixed(4);
                document.getElementById('tfTrainAcc').textContent = (logs.classOut_accuracy || 0).toFixed(3);
                document.getElementById('tfValLoss').textContent = (logs.val_loss || 0).toFixed(4);
                document.getElementById('tfValAcc').textContent = (logs.val_classOut_accuracy || 0).toFixed(3);
            }

            function clip(x, min, max) {
                return Math.max(min, Math.min(max, x));
            }

            // ==================== FEATURE EXTRACTION ====================
            /**
             * Extracts [windowSize, regions*3] window from currentSolution
             * Returns: Float32Array (flattened) or null
             */
            function extractWindowFromSolution(sol, windowSize = TF_WIDGET.windowSize) {
                if (!sol || !sol.t || !sol.L || !sol.C || !sol.S) {
                    throw new Error('Invalid solution structure');
                }

                const T = sol.t.length;
                if (T < 1) throw new Error('Empty solution');

                // Build [T, regions*3] array
                const data = [];
                for (let t = 0; t < T; t++) {
                    const row = [];
                    for (let r = 0; r < TF_WIDGET.regions; r++) {
                        row.push(sol.L[t][r] || 0, sol.C[t][r] || 0, sol.S[t][r] || 0);
                    }
                    data.push(row);
                }

                // Take last windowSize points (pad with zeros if needed)
                const start = Math.max(0, T - windowSize);
                const window = data.slice(start);
                while (window.length < windowSize) {
                    window.unshift(new Array(TF_WIDGET.regions * 3).fill(0));
                }

                // Flatten
                const flat = new Float32Array(windowSize * TF_WIDGET.regions * 3);
                let idx = 0;
                for (const row of window) {
                    for (const val of row) flat[idx++] = val;
                }

                return flat;
            }

            // ==================== NORMALIZATION ====================
            function computeNormalizer(dataset) {
                const n = dataset.length;
                const dim = dataset[0].x.length;

                // Compute mean
                const mean = new Float32Array(dim);
                for (const sample of dataset) {
                    for (let i = 0; i < dim; i++) mean[i] += sample.x[i];
                }
                for (let i = 0; i < dim; i++) mean[i] /= n;

                // Compute std
                const std = new Float32Array(dim);
                for (const sample of dataset) {
                    for (let i = 0; i < dim; i++) {
                        const diff = sample.x[i] - mean[i];
                        std[i] += diff * diff;
                    }
                }
                for (let i = 0; i < dim; i++) {
                    std[i] = Math.sqrt(std[i] / Math.max(1, n - 1));
                    if (std[i] < 1e-6) std[i] = 1.0; // avoid division by zero
                }

                return { mean, std };
            }

            function normalize(x, normalizer) {
                const result = new Float32Array(x.length);
                for (let i = 0; i < x.length; i++) {
                    result[i] = (x[i] - normalizer.mean[i]) / normalizer.std[i];
                }
                return result;
            }

            // ==================== DATA AUGMENTATION ====================
            function augmentSample(sample, normalizer) {
                const windowSize = TF_WIDGET.windowSize;
                const featDim = TF_WIDGET.regions * 3;
                const aug = new Float32Array(sample.length);

                // Random time shift (¬±3 timepoints)
                const timeShift = Math.floor((Math.random() - 0.5) * 6);

                for (let i = 0; i < sample.length; i++) {
                    const tIdx = Math.floor(i / featDim);
                    const newTIdx = clip(tIdx + timeShift, 0, windowSize - 1);
                    const offset = i % featDim;
                    const newIdx = newTIdx * featDim + offset;

                    // Add gaussian noise (œÉ=0.1 after normalization)
                    const noise = (Math.random() - 0.5) * 0.2;
                    aug[i] = sample[newIdx] + noise;
                }

                return aug;
            }

            // ==================== SYNTHETIC DATASET ====================
            function generateSyntheticDataset(N = 300, windowSize = TF_WIDGET.windowSize) {
                const examples = [];
                const scenarios = Object.keys(SCENARIO_PRESETS);

                for (let i = 0; i < N; i++) {
                    const scKey = scenarios[Math.floor(Math.random() * scenarios.length)];
                    const preset = SCENARIO_PRESETS[scKey];

                    const sample = new Float32Array(windowSize * TF_WIDGET.regions * 3);

                    // Random global drifts
                    const driftL = (Math.random() - 0.5) * 1.5;
                    const driftC = (Math.random() - 0.5) * 1.5;
                    const driftS = (Math.random() - 0.5) * 1.2;

                    let idx = 0;
                    for (let t = 0; t < windowSize; t++) {
                        const tFrac = t / windowSize;
                        for (let r = 0; r < TF_WIDGET.regions; r++) {
                            const regionNoise = (Math.random() - 0.5) * 0.4;
                            const timeNoise = (Math.random() - 0.5) * 0.3;

                            const L = clip(preset.L + driftL * tFrac + regionNoise + timeNoise, 0, 10);
                            const C = clip(preset.C + driftC * tFrac + regionNoise * 0.8 + timeNoise, 0, 10);
                            const S = clip(preset.S + driftS * tFrac + regionNoise * 0.6 + timeNoise, 0, 10);

                            sample[idx++] = L;
                            sample[idx++] = C;
                            sample[idx++] = S;
                        }
                    }

                    // Label: use mean L from last timepoint
                    const lastOffset = (windowSize - 1) * (TF_WIDGET.regions * 3);
                    let sumL = 0;
                    for (let r = 0; r < TF_WIDGET.regions; r++) {
                        sumL += sample[lastOffset + r * 3];
                    }
                    const meanL = sumL / TF_WIDGET.regions;
                    const pci = meanL / 10.0;

                    // Clinical classification
                    let cls = 4;
                    if (meanL < 2.5) cls = 0;
                    else if (meanL < 4.0) cls = 1;
                    else if (meanL < 5.5) cls = 2;
                    else if (meanL < 7.0) cls = 3;

                    examples.push({ x: sample, yClass: cls, yPCI: pci });
                }

                return examples;
            }

            // ==================== MODEL BUILDER ====================
            function buildModel(inputDim) {
                const input = tf.input({ shape: [inputDim] });

                // Deeper architecture: 1248 -> 512 -> 128 -> 64 (bottleneck)
                let x = tf.layers.dense({ units: 512, activation: 'relu', kernelInitializer: 'heNormal' }).apply(input);
                x = tf.layers.batchNormalization().apply(x);
                x = tf.layers.dropout({ rate: 0.3 }).apply(x);

                x = tf.layers.dense({ units: 128, activation: 'relu', kernelInitializer: 'heNormal' }).apply(x);
                x = tf.layers.batchNormalization().apply(x);

                const bottleneck = tf.layers.dense({ units: 64, activation: 'relu', name: 'bottleneck' }).apply(x);
                const dropout = tf.layers.dropout({ rate: 0.25 }).apply(bottleneck);

                // Dual heads
                const classOut = tf.layers.dense({
                    units: TF_WIDGET.classes.length,
                    activation: 'softmax',
                    name: 'classOut'
                }).apply(dropout);

                const pciOut = tf.layers.dense({
                    units: 1,
                    activation: 'linear',
                    name: 'pciOut'
                }).apply(dropout);

                const model = tf.model({ inputs: input, outputs: [classOut, pciOut] });

                model.compile({
                    optimizer: tf.train.adam(parseFloat(document.getElementById('tfLR').value)),
                    loss: {
                        classOut: 'categoricalCrossentropy', // one-hot labels
                        pciOut: 'meanSquaredError'
                    },
                    metrics: {
                        classOut: ['accuracy'],
                        pciOut: ['mse']
                    }
                });

                return model;
            }

            // ==================== TRAINING ====================
            async function trainOnSynthetic() {
                const N = 300;
                const epochs = parseInt(document.getElementById('tfEpochs').value);
                const batchSize = parseInt(document.getElementById('tfBatch').value);
                const useAugment = document.getElementById('tfAugment').checked;
                const useNorm = document.getElementById('tfNormalize').checked;

                logTF(`Generating ${N} synthetic examples...`, 'info');
                const dataset = generateSyntheticDataset(N);

                // Compute normalizer
                if (useNorm) {
                    TF_WIDGET.normalizer = computeNormalizer(dataset);
                    logTF('Z-score normalization computed', 'success');
                } else {
                    TF_WIDGET.normalizer = null;
                }

                // Apply normalization
                if (TF_WIDGET.normalizer) {
                    for (const sample of dataset) {
                        sample.x = normalize(sample.x, TF_WIDGET.normalizer);
                    }
                }

                // Data augmentation (double dataset size)
                if (useAugment) {
                    const augmented = [];
                    for (const sample of dataset) {
                        augmented.push({
                            x: augmentSample(sample.x, TF_WIDGET.normalizer),
                            yClass: sample.yClass,
                            yPCI: sample.yPCI
                        });
                    }
                    dataset.push(...augmented);
                    logTF(`Augmentation: ${dataset.length} total samples`, 'success');
                }

                // Convert to tensors
                const inputDim = dataset[0].x.length;
                const X = tf.tensor2d(dataset.map(d => Array.from(d.x)), [dataset.length, inputDim]);

                // One-hot encode class labels (CRITICAL FIX)
                const numClasses = TF_WIDGET.classes.length;
                const yClassArr = dataset.map(d => {
                    const oneHot = new Array(numClasses).fill(0);
                    oneHot[d.yClass] = 1;
                    return oneHot;
                });
                const yClass = tf.tensor2d(yClassArr, [dataset.length, numClasses], 'float32');

                const yPCI = tf.tensor2d(dataset.map(d => [d.yPCI]), [dataset.length, 1]);

                // Build model
                logTF('Building model...', 'info');
                TF_WIDGET.model = buildModel(inputDim);

                // Reset history
                TF_WIDGET.trainingHistory = {
                    loss: [], val_loss: [], acc: [], val_acc: [], pci_mse: [], val_pci_mse: []
                };

                // Training
                tfProgressBar.style.display = 'block';
                updateProgress(0);

                logTF(`Training: ${epochs} epochs, batch ${batchSize}...`, 'info');

                try {
                    await TF_WIDGET.model.fit(X, { classOut: yClass, pciOut: yPCI }, {
                        epochs,
                        batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochBegin: async () => {
                                await tf.nextFrame();
                            },
                            onEpochEnd: async (epoch, logs) => {
                                // Update history
                                TF_WIDGET.trainingHistory.loss.push(logs.loss);
                                TF_WIDGET.trainingHistory.val_loss.push(logs.val_loss || null);
                                TF_WIDGET.trainingHistory.acc.push(logs.classOut_accuracy);
                                TF_WIDGET.trainingHistory.val_acc.push(logs.val_classOut_accuracy || null);
                                TF_WIDGET.trainingHistory.pci_mse.push(logs.pciOut_mse);
                                TF_WIDGET.trainingHistory.val_pci_mse.push(logs.val_pciOut_mse || null);

                                // Update UI
                                const progress = ((epoch + 1) / epochs) * 100;
                                updateProgress(progress);
                                updateMetrics(logs);

                                logTF(`Epoch ${epoch + 1}/${epochs} ‚Äî val_loss=${(logs.val_loss || 0).toFixed(4)} val_acc=${(logs.val_classOut_accuracy || 0).toFixed(3)}`, 'info');

                                // Update training curves every 2 epochs
                                if (epoch % 2 === 0 || epoch === epochs - 1) {
                                    updateTrainingCurves();
                                }

                                await tf.nextFrame();
                            }
                        }
                    });

                    updateProgress(100);
                    logTF('‚úÖ Training complete! Model ready for inference.', 'success');

                } catch (err) {
                    console.error('Training error:', err);
                    logTF(`Training failed: ${err.message}`, 'error');
                } finally {
                    // Cleanup tensors
                    X.dispose();
                    yClass.dispose();
                    yPCI.dispose();
                    tfProgressBar.style.display = 'none';
                    await tf.nextFrame();
                }
            }

            // ==================== INFERENCE ====================
            async function inferCurrentSolution() {
                if (!TF_WIDGET.model) {
                    logTF('No model loaded. Train first.', 'warning');
                    return;
                }
                if (!currentSolution) {
                    logTF('No simulation data (currentSolution is null). Run a simulation first.', 'warning');
                    return;
                }

                try {
                    // Extract features
                    let flat = extractWindowFromSolution(currentSolution);

                    // Normalize
                    if (TF_WIDGET.normalizer) {
                        flat = normalize(flat, TF_WIDGET.normalizer);
                    }

                    const inputDim = flat.length;
                    const xs = tf.tensor2d([Array.from(flat)], [1, inputDim]);

                    // Predict
                    const [predProbs, predPCI] = TF_WIDGET.model.predict(xs);
                    const probs = Array.from(await predProbs.data());
                    const pciVal = (await predPCI.data())[0];

                    // Cleanup tensors (CRITICAL FIX for memory leak)
                    xs.dispose();
                    predProbs.dispose();
                    predPCI.dispose();

                    // Update visualizations
                    plotProbs(probs);
                    await plotLatentProjection(flat);

                    // Log results
                    const maxIdx = probs.indexOf(Math.max(...probs));
                    const predictedLabel = TF_WIDGET.classes[maxIdx];
                    logTF(`Predicted: ${predictedLabel} (p=${probs[maxIdx].toFixed(3)}), PCI‚âà${pciVal.toFixed(3)}`, 'success');

                    // Update main status bar
                    document.getElementById('statusText').textContent =
                        `ü§ñ ML: ${predictedLabel} (conf=${(probs[maxIdx] * 100).toFixed(0)}%), PCI=${pciVal.toFixed(3)}`;

                } catch (err) {
                    console.error('Inference error:', err);
                    logTF(`Inference failed: ${err.message}`, 'error');
                }
            }

            // ==================== FEATURE IMPORTANCE ====================
            async function computeFeatureImportance() {
                if (!TF_WIDGET.model) {
                    logTF('No model. Train first.', 'warning');
                    return;
                }

                try {
                    logTF('Computing feature importance...', 'info');

                    // Extract weights from first dense layer
                    const firstDense = TF_WIDGET.model.layers.find(l => l.name.includes('dense'));
                    if (!firstDense) throw new Error('No dense layer found');

                    const weights = firstDense.getWeights()[0]; // [inputDim, units]
                    const wData = await weights.array();

                    // Compute L2 norm for each input feature
                    const inputDim = wData.length;
                    const importance = new Array(inputDim);
                    for (let i = 0; i < inputDim; i++) {
                        let sum = 0;
                        for (const val of wData[i]) sum += val * val;
                        importance[i] = Math.sqrt(sum);
                    }

                    // Aggregate by region and variable (L/C/S)
                    const regionImportance = new Array(TF_WIDGET.regions).fill(0).map(() => ({ L: 0, C: 0, S: 0 }));
                    for (let t = 0; t < TF_WIDGET.windowSize; t++) {
                        for (let r = 0; r < TF_WIDGET.regions; r++) {
                            const idx = t * (TF_WIDGET.regions * 3) + r * 3;
                            regionImportance[r].L += importance[idx];
                            regionImportance[r].C += importance[idx + 1];
                            regionImportance[r].S += importance[idx + 2];
                        }
                    }

                    // Normalize to [0, 1]
                    const maxImp = Math.max(...regionImportance.flatMap(ri => [ri.L, ri.C, ri.S]));
                    if (maxImp > 0) {
                        regionImportance.forEach(ri => {
                            ri.L /= maxImp;
                            ri.C /= maxImp;
                            ri.S /= maxImp;
                        });
                    }

                    // Plot heatmap
                    const trace = {
                        type: 'heatmap',
                        z: [
                            regionImportance.map(ri => ri.L),
                            regionImportance.map(ri => ri.C),
                            regionImportance.map(ri => ri.S)
                        ],
                        x: REGIONS,
                        y: ['L', 'C', 'S'],
                        colorscale: 'Viridis',
                        colorbar: { title: 'Importance' }
                    };

                    const layout = {
                        title: '',
                        margin: { l: 50, r: 80, t: 40, b: 80 },
                        xaxis: { tickangle: -45 }
                    };

                    Plotly.react('tfPlotImportance', [trace], layout, { responsive: true });
                    logTF('Feature importance computed', 'success');

                } catch (err) {
                    console.error('Importance error:', err);
                    logTF(`Importance calculation failed: ${err.message}`, 'error');
                }
            }

            // ==================== VISUALIZATION ====================
            function plotProbs(probs) {
                const colors = probs.map(p => `rgba(102, 126, 234, ${0.3 + 0.7 * p})`);
                const trace = {
                    x: TF_WIDGET.classes,
                    y: probs,
                    type: 'bar',
                    marker: { color: colors, line: { width: 1, color: '#667eea' } }
                };
                const layout = {
                    title: '',
                    margin: { l: 50, r: 30, t: 40, b: 70 },
                    yaxis: { range: [0, 1], title: 'Probability' },
                    xaxis: { tickangle: -30 }
                };
                Plotly.react('tfPlotProbs', [trace], layout, { responsive: true });
            }

            async function plotLatentProjection(flatInput) {
                if (!TF_WIDGET.model) return;

                try {
                    // Generate local perturbations (30 points)
                    const nPoints = 30;
                    const inputDim = flatInput.length;
                    const samples = [];

                    for (let i = 0; i < nPoints; i++) {
                        const pert = new Float32Array(inputDim);
                        for (let k = 0; k < inputDim; k++) {
                            pert[k] = flatInput[k] + (Math.random() - 0.5) * 0.4; // œÉ=0.2
                        }
                        samples.push(pert);
                    }

                    // Get bottleneck embeddings
                    const bottleneck = TF_WIDGET.model.getLayer('bottleneck');
                    if (!bottleneck) throw new Error('No bottleneck layer');

                    const subModel = tf.model({ inputs: TF_WIDGET.model.inputs, outputs: bottleneck.output });
                    const X = tf.tensor2d(samples.map(s => Array.from(s)), [nPoints, inputDim]);
                    const Z = subModel.predict(X); // [nPoints, 64]
                    const Zmat = await Z.array();

                    X.dispose();
                    Z.dispose();

                    // PCA via SVD (if available)
                    if (tf.linalg && typeof tf.linalg.svd === 'function') {
                        const Ztf = tf.tensor2d(Zmat);
                        const mean = Ztf.mean(0);
                        const Zc = Ztf.sub(mean);

                        const svd = tf.linalg.svd(Zc, true);
                        const V = svd.v;
                        const V2 = V.slice([0, 0], [V.shape[0], 2]);
                        const proj = Zc.matMul(V2);
                        const projArr = await proj.array();

                        // Cleanup
                        Ztf.dispose();
                        mean.dispose();
                        Zc.dispose();
                        if (svd.u) svd.u.dispose();
                        if (svd.s) svd.s.dispose();
                        V.dispose();
                        V2.dispose();
                        proj.dispose();

                        const trace = {
                            x: projArr.map(p => p[0]),
                            y: projArr.map(p => p[1]),
                            mode: 'markers',
                            marker: { size: 8, color: '#667eea', opacity: 0.6 },
                            type: 'scatter'
                        };

                        const layout = {
                            title: 'Latent Space (PCA projection)',
                            margin: { l: 50, r: 30, t: 40, b: 50 },
                            xaxis: { title: 'PC1' },
                            yaxis: { title: 'PC2' }
                        };

                        Plotly.react('tfPlotLatent', [trace], layout, { responsive: true });
                    } else {
                        // Fallback: first 2 dimensions
                        const trace = {
                            x: Zmat.map(z => z[0]),
                            y: Zmat.map(z => z[1]),
                            mode: 'markers',
                            marker: { size: 8, color: '#667eea', opacity: 0.6 },
                            type: 'scatter'
                        };

                        Plotly.react('tfPlotLatent', [trace], { title: '' }, { responsive: true });
                    }

                } catch (err) {
                    console.warn('Latent projection failed:', err);
                }
            }

            function updateTrainingCurves() {
                const h = TF_WIDGET.trainingHistory;
                const epochs = h.loss.map((_, i) => i + 1);

                const traces = [
                    {
                        x: epochs,
                        y: h.loss,
                        name: 'Train loss',
                        line: { color: '#e74c3c', width: 2 }
                    },
                    {
                        x: epochs,
                        y: h.val_loss,
                        name: 'Val loss',
                        line: { color: '#e74c3c', width: 2, dash: 'dot' }
                    },
                    {
                        x: epochs,
                        y: h.acc,
                        name: 'Train acc',
                        yaxis: 'y2',
                        line: { color: '#2ecc71', width: 2 }
                    },
                    {
                        x: epochs,
                        y: h.val_acc,
                        name: 'Val acc',
                        yaxis: 'y2',
                        line: { color: '#2ecc71', width: 2, dash: 'dot' }
                    }
                ];

                const layout = {
                    title: '',
                    margin: { l: 50, r: 60, t: 40, b: 50 },
                    xaxis: { title: 'Epoch' },
                    yaxis: { title: 'Loss', side: 'left' },
                    yaxis2: {
                        title: 'Accuracy',
                        overlaying: 'y',
                        side: 'right',
                        range: [0, 1]
                    },
                    legend: { x: 1.1, y: 1 }
                };

                Plotly.react('tfPlotTraining', traces, layout, { responsive: true });
            }

            // ==================== EXPORT/CLEAR ====================
            async function exportModel() {
                if (!TF_WIDGET.model) {
                    logTF('No model to export', 'warning');
                    return;
                }

                try {
                    logTF('Exporting model (tfjs format)...', 'info');
                    await TF_WIDGET.model.save('downloads://dcd4_tfjs_model');

                    // Also export normalizer as JSON
                    if (TF_WIDGET.normalizer) {
                        const normJSON = JSON.stringify({
                            mean: Array.from(TF_WIDGET.normalizer.mean),
                            std: Array.from(TF_WIDGET.normalizer.std)
                        }, null, 2);

                        const blob = new Blob([normJSON], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'dcd4_normalizer.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    }

                    logTF('Model + normalizer exported', 'success');
                } catch (err) {
                    console.error('Export error:', err);
                    logTF(`Export failed: ${err.message}`, 'error');
                }
            }

            function clearModel() {
                if (TF_WIDGET.model) {
                    TF_WIDGET.model.dispose();
                    TF_WIDGET.model = null;
                    TF_WIDGET.normalizer = null;
                    TF_WIDGET.trainingHistory = { loss: [], val_loss: [], acc: [], val_acc: [], pci_mse: [], val_pci_mse: [] };

                    // Clear plots
                    Plotly.purge('tfPlotProbs');
                    Plotly.purge('tfPlotLatent');
                    Plotly.purge('tfPlotTraining');
                    Plotly.purge('tfPlotImportance');

                    tfMetrics.style.display = 'none';
                    logTF('Model cleared from memory', 'success');
                } else {
                    logTF('No model to clear', 'warning');
                }
            }

            // ==================== EVENT HANDLERS ====================
            trainBtn.addEventListener('click', async () => {
                trainBtn.disabled = true;
                inferBtn.disabled = true;
                importanceBtn.disabled = true;
                exportBtn.disabled = true;
                clearBtn.disabled = true;

                try {
                    await trainOnSynthetic();
                } catch (err) {
                    console.error('Training pipeline error:', err);
                    logTF(`Training failed: ${err.message}`, 'error');
                } finally {
                    trainBtn.disabled = false;
                    inferBtn.disabled = false;
                    importanceBtn.disabled = false;
                    exportBtn.disabled = false;
                    clearBtn.disabled = false;
                }
            });

            inferBtn.addEventListener('click', async () => {
                inferBtn.disabled = true;
                try {
                    await inferCurrentSolution();
                } catch (err) {
                    console.error('Inference error:', err);
                    logTF(`Inference failed: ${err.message}`, 'error');
                } finally {
                    inferBtn.disabled = false;
                }
            });

            importanceBtn.addEventListener('click', async () => {
                importanceBtn.disabled = true;
                try {
                    await computeFeatureImportance();
                } catch (err) {
                    console.error('Importance error:', err);
                    logTF(`Importance failed: ${err.message}`, 'error');
                } finally {
                    importanceBtn.disabled = false;
                }
            });

            exportBtn.addEventListener('click', exportModel);
            clearBtn.addEventListener('click', clearModel);

            // ==================== INITIALIZATION ====================
            logTF('Enhanced TF.js widget v2.0 initialized', 'success');
            console.log('[TFWidget] Ready. TensorFlow.js version:', tf.version.tfjs);

        })();
    </script>

</body>
</html>
